19th January 2016
---------------------

Today I implemented the code for moving platforms. This required a new "MovingPlatform" script, and some changes to the "Player" script.

I originally thought the process would be very simple. I could use the same principles I used to allow the AI agent to move, in order to
allow the platform to move. This is the code I added to the "MovingPlatform" script, and it pretty much did the job. The platform I attached the script to
moved nicely. If I jumped onto it with the player character, the collision worked fine, and I could ride it down. However on the way back up, the 
PlayCharacter would play the "Falling" animation and I would lose all control of it until the platform reached the top and started to move back down again.
Clearly this needed to be fixed.

I decided the best course of action was to edit the "Player" script so that the it could detect when the player was stood on ontop of the moving platform
and ensure that the falling animation did not play.

I believe the reason this bug occurred at all was due to the fact that the colliders on the players feet and the platform weren't behaving correctly so I
couldn't use them to detect whether or not the player is on the platform so I decided instead to look at the player's X/Y coordinates and check them against
the X/Y coordinates of the platform. If they were close enough to each other, I could treat the player as if he was just stood on solid ground, and therefore
the player wouldn't lose control, and the falling animation wouldn't play.

This actually worked pretty well. The main complexity came when I needed to consider how to implement this for multiple moving platforms throughout the level,
as they will all have their own set of X/Y coordinates. I originally tried to loop through all of the MovingPlatforms I could find using the line 
"GameObject.Find("MovingPlatform (" + index.ToString() + ")");" but this was causing performance issues as GameObject.Find is a performance intensive operation,
and I was calling it multiple times in a loop, every time the Update() procedure was called.

I decided the best course of action to correct this was to create an ArrayList and populate it with all of the MovingPlatforms using GameObject.Find
within the Start() procedure. I could then access the arraylist later within the Update() method with much less of a hit to performance.

20th January 2016
-----------------------

Added a shooting animation. Note that no back end projectile system is in place yet, there is no collision detection on projectiles and health and damage 
systems still don't exist for the player and enemies. Animating the player for shooting was fairly similar to most other animations so that was done fairly 
quickly. The new challenge to this task was to spawn the projectiles in the game. This was done with a simple bullet script, and some changes to the player
script.

The first step was to make the bullet animation a prefab (this is basically just a template from which objects can be created). Once this was done, I made
a SerializedField in the player script so that I could simply drag the prefab into it from Unity, this then gives me access to the prefab within the player
script. I then wrote a function that instantiates the bullet prefab. I needed the bullet to know which direction to travel in once it had been fired so
I needed to pass a Vector to a function in the Bullet script based on which way the player is facing.

The Bullet script was fairly simple. The initialize function decided on the direction it should travel based on the Vector passed by the Player script,
after this the bullet simply set it's velocity to speed( a serialized field) * direction. Due to the fact that the player script can create these objects
at a rapid rate, the bullet objects needed to know when to destroy themselves otherwise I could run into serious performance issues. Currently I am overriding
the OnBecameInvisible function (which is called whenever an object is not within view of the camera) so that the bullets destroy themselves whenever they
leave the Camera's view. However this will likely need to be changed in the future.

Overall I expect the Bullet script to become more complex when I start to add the back end projectile system.

Added an "Agent" Script, this will be the super class for all simple AI agents. Almost all of "Slimes" functionality is currently inherited.

21st January 2016
------------------

Today I started work on damage and health for the player and the AI. After creating all 4 animations, I then  gave both of them an integer "hitpoints" 
that keeps track of health. I also created two new functions in each. One responsible for damaging the health, and one to check whether or not the 
player or agent is still alive.

Once this was done, it was possible for both player and AI to keep track of their health, damage it and play the death animation when necessary, so the next
step was to actually create things to trigger damage on each of them.

I added a collider to the "Bullet" prefab, and then in the Agent script I wrote the OnTriggerEnter2D function (called when something collides with the agent's
hitbox.). I made this function check to see if the object that collided with the agent is a bullet, and if so, call the TakeDamage function for the agent.

The next thing I worked on was the player's melee attack. I created a new collider that is actually disabled by default. When the player presses the melee
attack key, the collider is enabled. In this way I can use the OnTriggerEnter2D function in the agent script to check if it has collided with the player's
melee attack hitbox, if so it could call the TakeDamage function.

This was particularly challenging because there seems to be a bug where if the player is stood still and the agent is stood next to him, and the player
attacks, the agent does not register the hit. Obviously this is very bad because that is one of the few times someone would want to use a melee attack.
A fix to this that seems to work for now is to increase the player's velocity by a negligible amount, this makes the agent register the hit. Although
I would like to revisit this fix and hopefully come up with a nicer solution. 


25th January 2016
-----------------
Today I added the functionality for the Slime AI to attack the player. At first this was quite similar to how it worked for the player. I added a meleehithox
to the slime and told it to enable the hitbox when it called its attack function. I told the player to take damage if it collided with the Slime's meleehitbox.
The problem with this was that the slime actually doesn't have an attack animation. So it was calling the attack function far too quickly and was instantly
killing the player. Although this could pose an interesting challenge I don't think it is acceptable for the first AI the player is going to encounter.
I added functionality to temporarily provide immunity to the player after taking damage. This was tricky to implement at first, I toyed with the idea
of using a seperate thread to track this but later came across the Time.deltaTime property in C# which allowed me to write my own UpdateImmunity function 
instead.

Next I would like to make the slime back off after attacking so that it gives the appearance that the slime is hurting the player with it's momentum
rather than it's mere presence (due to the lack of an attack animation.)

I added the code to the agent script to make the slime back off between attacks. I also added code to the Player script to make the player sprite
flicker while it is immune to damage. This provides a useful visual cue to the player.


26th January 2016
------------------
Yesterday I found that the code for the agent was becoming quite complex and it seemed like alot of code to have inside just one script, and I felt like it
would likely be difficult to maintain going forward, especiall as I add a larger variety of AI agents to the game. As such I decided to redesign the code
to use the State design pattern for the AI agents. I have an Interface (IAgentState) and at the moment I have 4 concrete implementations of that, each
representing a state the AI might need to be in. (IdleState, PatrolState, ChaseState, MeleeAttackState) The Agent script looks at the environment and 
decides which state it should be in, and then the concrete implementation of state deals with how the agent should act.

This should help keep code for each different state seperated and clearer in the long run.


27th January 2016
-----------------
Finished collision entirely for first level. Some adjustments may still be necessary but all colliders are now in place for ground walls ceilings and platforms.

Added the "Bat" to the game. This involved creating 3 animations (fly, damage and death). The Bat script inherits from Agent, and of course makes use of
the State machine for it's AI in the same way the Slime agent does.

The notable difference between the Bat AI and the Slime AI is that I want the bat to be able to chase the player across the whole level, whereas a slime will
give up if the player leaves the area between it's two patrol points.

To do this I needed to override some agent methods in the bat class. Firstly I wanted to override the PlayerMeleeRange method to make it check the Y coordinates
of the player and the agent before letting the bat attack as the bat flies obviously. However after doing this I noticed that the slime AI switches between
patrol and melee states even when the player is nowhere near and this is caused by the Slime not checking the Y values of the player. This really was quite
and obvious bug but I caught it, and decided that instead of overriding the method in bat to check the Y, that the base functionality should check the Y
value so I simply modified the method inside the Agent class instead.

Next I needed to override the  Agent LookForPlayer method in Bat to allow the bats to search further along the Y axis for the player, this allows them to 
enter the chase state more easily as intended.

The next thing I needed to do was ensure that the bats and slimes chased in different ways. It occurred to me that I could have the functionality in each
of their respective classes and then call that procedure from the ChaseState class, but after some thought I felt like the whole point of the state machine
pattern is to minimize action functionality inside the respective agent's class. So instead, I simply checked which kind of agent the ChaseState class was
dealing with, and altered functionality based on that.

The main difference is that the Bat now also tries to chase the player along the Y axis. This works fairly well at the moment but unfortunately the bat gets
stuck on obstacles.

After some research it seems that pathfinding is the answer to this problem. I might attempt to implement some sort of pathfinding at a later date if the 
problem is not resolved by then.


28th January 2016
------------------
Added the third AI today. The "Worm" AI. This involved creating all of the animations, (Idle, walk, damage, death and attack.) As this was the first enemy
sprite that had an attack animation included, I needed to add some new code to the MeleeAttack state in order for it to work correctly (i.e I wanted to 
trigger the attack animation rather than just have the mob bounce off the player like the Bat and Slime did.) This also meant that enabling and disabling
the HitBox needed to be triggered by animation events in much the same way the player's melee hit box is triggered when it attacks.

As this is a melee mob, in order to make the AI unique from the slime, I added functionality for it to hide from the player if the player is nearby and out of
reach. The reasoning behind this is that if the player is stood on another platform where the Worm is unable to reach (because it can't jump). Then the worm
is at risk of being shot. So in this scenario it attempts to hide by running away to the other end of it's patrol point. This hopefully removes it from the 
player's view so that bullets despawn before reaching the agent. If the player then steps onto the agents platform, the worm will chase the player and attempt
to melee attack him.

This involved creating a new state, HideState, which the Worm enters if the player is nearby but out of reach.

29th January 2016
------------------
Platforms Powerups and Ladders. Still to do levers and door.


1st February 2016
------------------
Added scripts for levers , door and level transition.

Today I added the levers, switches and exit door to the game. Each of these required animations. The switches are simply to signify whether or not the 
corresponding lever has been pulled. This is so the player can use their intuition to figure out that the door needs to be unlocked and that pulling levers
is the way to do that. Each lever has a script attached to control their animation, if the player presses the "Use" key (which temporarily spawns a box 
collider infront of him, much like a melee attack) near the lever, it plays the animation for the lever being pulled.

I also attached a script to the door which controls the animation for the door and the switches. This script constantly checks the status of the levers and if
it sees that a lever has been pulled, it switches on the corresponding switch. If both switches are on, it plays the door open animation, and activates it's
level transition trigger. This trigger has the LevelTransition script attached to it which basically checks to see if the player is inside the trigger,
and if the player is inside and also presses the "w" key, the script will load the next level.

8th February 2016
------------------
Created the level for the first boss fight. This is a simplistic level as the only challenge I really want to present the player with here is the boss itself.
Also I don't want their to be a great deal of obstacles for the boss. As such the level is flat with just a few spike obstacles for the player and boss
to navigate.

9th February 2016
-----------------
Today I created the boss agent. I used a player sprite from another sprite package as this means there are a great deal of animations I can use for the boss,
meaning I can make it do more complex things as there are animations to support it.

Today I added animations for Idling, running, melee attack, knife throwing, taking damage, jumping and falling.

Most of these were fairly simple as I have already done it multiple times for other agents, but knife throwing was fairly difficult as it hasn't been done
before. I followed a similar process to how I implemented shooting for the player and this worked successfully. I spent alot of time on this as originally the
knife was spawning inside of the boss' hitbox, hitting the inside edge of it and then despawning. This made it appear to me as if the knife wasn't spawning
at all so I spent a great deal of time looking for mistakes in the code when really the problem was as simple as the position the knife is spawning in at.

The next big challenge was to get jumping working for the boss. Again I implemented this in a way that is similar to the player jump. The boss checks if it
is on the ground, and if so weights the ground layer to be in control, if it is in the air however, it weights the air layer to be in control of animation.
Currently the code for the boss just causes him to jump constantly, this will be changed tomorrow. I will also likely created a RangedAttackState and a JumpState
tomorrow for more code reuse and better readability. 

I intend to use a trigger near the spike obstacles to let the boss agent know when he needs to jump.


10th February 2016
-------------------
Today I wrote the main logic for the boss. This involved creating two new scripts. The RangedAttackState and the PhaseChangeState. RangedAttack will likely
be used quite alot in the future for any mobs in subsequent levels that need to be able to use ranged attacks.

I wanted the boss fight to start off in melee combat, then once the boss has lost a certain amount of health, I wanted him to jump to another platform and
begin throwing knives at the player. To do this I needed to use phases. The first "phase" being the melee phase. The second phase being the ranged phase.
So whilst the boss is in the first phase, he uses certain logic to decide which state he needs to be in. While in the second phase he uses different logic
and has a different set of states to choose from. 

To elaborate, in phase one the boss can choose from "IdleState" "PatrolState" "MeleeAttackState", "PhaseChangeState" and "ChaseState". While in phase two 
the boss can choose from "PhaseChangeState", "MeleeAttackState" and "RangedAttackState".

The actual code logic uses four phases, this is due to the fact that there are four platforms in the level but I will likely try to tidy up /simplify
this logic in the future.

For the boss to be able to jump across platforms I used a trigger near the edge of the platform that notifies him that he needs to perform a jump. Once he 
is on the platform I use another trigger to notify the Boss that it has successfully enterred the next phase, so it needs to use the logic for the next 
phase.

This caused a bug as his throwing knives were originally coded to despawn when they collide with a trigger. I made changes to this code so that they would 
ignore the phase and jump triggers.

I tuned up the damage of the throwing knives from 10 to 20 and slowed their speed down because it is more fun if enemy attacks hit harder but are avoidable
as this rewards skillful play.

There is currently a bug where when the boss changes phases his animation doesn't make the switch from melee to run fast enough.

I Still need to write the code for when the boss reaches 0 hp, the door opens and he runs away.


11th February 2016
-------------------
Fixed yesterdays animation bug for when the boss changes phases. I added a new animation transition between Boss Melee and Boss Run states that occurs
whenever speed > 0.01. This actually caused a new bug which made the boss unable to finish his melee attack animation while trying to attack the player.
The cause of this was in the MeleeAttackState code as it sets the speed to 1 in the MoveToPlayer procedure but never sets it back to 0 again. So I added
code in the Attack procedure to set speed back to 0 if the agent is a worm or a boss. This fixed the new bug. I also needed to add a transition from Boss Hurt
to Boss run that occurs when speed is greater than 0.01 so that at the start of the phase change the boss isn't playing the "Boss Hurt" aniamtion at the start
of the phase change. All animations now appear to be working correctly.

Found a bug where player can land on spikes and not die if he takes damage just prior to it, the immunity saves him. Fixed by changing code so spikes ignore
immunity.

Added script to make boss exit the level when his hp reaches 0. Also created new script to open the exit door when the boss is on 0 hp. Finished adding
decorations to first level.

Found a bug where boss could be forced to despawn if pushed into the collider. Added a check in the code to ensure he is on 0 hp before despawning.


15th February 2016
------------------
Built the second level. This was a time consuming process as it involved lots of tile placement as before. However I was also able to reuse many assets that
were created for level one. For example, ladders, the exit door, the jump powerup, spike obstacles and moving platforms. This helped save some time. For this
level I intend to have an AI that uses ranged attacks, and AI that searches for and uses powerups and some third AI.


17th February 2016
------------------
Added collision to level two. This involved adding box colliders to each of the land masses so that the player doesn't fall through the level. platforms did
not need collision added to them as they handle that themselves due to the different nature of collision on platforms.

Encountered a bug with ladders where if the player jumped off the ladder before reaching the top (ie before his climb speed was set to zero and he enterred
the climb idle animation) he would be stuck playing the climb animation while running along the platform. This was fixed by adding code to player script to
check whether or not the player is on a ladder, and if not set climb speed to zero to allow the animator to transition back to the necessary animations.

Added a new AI to the game. This AI is called the "Crawler" AI. It needed run, damage, death and shoot animations to be created for it, aswell as all the 
necessary transitions. It also needed a new script to be created, like the rest of the AI scripts, this inherits from Agent to reuse code for common
functionality. This agent makes use of the following states : Idle, Patrol, Hide, RangedAttack. The RangedAttack state was only recently created to be used
for the first boss fight but it works very well for the crawler aswell. I modified the code slightly for ranged attack state as when it was first written it
actually was only capable of attacking to the left which worked for the boss fight but really shouldn't have been written that way so the code has been
rectified so that the agent (Boss or crawler) can now use ranged attacks in either direction.

I wrote the logic for the crawler in such a way that if it enters the hide state, it will remain in that state unless it is able to use ranged attacks on the
player. i.e it will not transition from the hide state back to patrol state for at least 20 seconds.

animation for shooting was making the agent jump so I corrected the pivot point of the death animation (because I use 2 clips from that to shoot) and this
fixed the issue.


23rd February 2016
------------------
Created a new powerup. This powerup increases the melee attack power of the player when it is activated. I used the same sprite as the one used for the jump
powerup but I put a blue filter over it. When the players collision box hits the powerup's collision box, a "MeleePowerUp" boolean is set to true for the 
player. While this boolean is set to true, the player will turn blue whenever he uses a melee attack (this is to show the player that the powerup is active).

Due to the fact that it is the agent class that dictates how much damage enemies receive, it was necessary to add new code to check the color of the player
sprite before calculating how much damage to take (because if the sprite is blue the player has the powerup so more damage should be taken.)

I also created a new AI today called a "Seeker". What makes this AI unique is that when it sees that the player is in range, it attempts to seek out a
melee attack powerup to activate on itself before attacking the player. This required me to add a new agent state (SeekPowerState) to handle the search for
the powerup.

I also needed to add alot of unique code to the Seeker class so that it can actually handle the powerup, as it is the first agent capable of activating them.
The code was similar to the code I wrote for the player where the time remaining on the powerup is constantly checked and at a certain point the sprite will
flicker and then go back to normal.

I still need to modify the code for the HideState for the seeker so that it won't accidentally pick up the powerup when hiding, and I still need to add the
damage functionality for when the seeker hits the player. 


24th February 2016
-------------------
Modified code of hide state to prevent the seeker from accidentally picking up the powerup. 

Found a bug where if player jumps onto platform and quickly jumps back off, seeker gets stuck in seekpowerup state.

Bug was caused by me not allowing access into patrol state if the agent is already in the seekpower state. The original thinking behind this was that I didn't
want the agent to be constantly switching between the two states as it might hamper its ability to get to the powerup. However after removing this code, it
seems that the agent is still able to collect the powerup in the same manner as before, and it also fixes the bug where the agent is stuck in the seekpower
state.

Added the functionality for damaging the player. This was done by creating two melee hit boxes for the agent rather than just one. The second one would be
used while the powerup is active. So I overrided the two methods in agent (EnableHitBox and DisableHitBox) so that they enable and disable the correct 
hitboxes depending on whether or not the agent has the powerup active.

It was then just a case of adding code to the playerscript to take the correct amount of damage depending on which hitbox collides with the player.

25th February 2016
------------------
Did second boss.


29th February 2016
------------------
Created third level


1st March 2016
---------------
Created third boss fight, was a mixture of first and second boss.

Created health bar system. I created the graphic for the health bar myself, In unity I use a mask in order to keep the health bar in the correct position.
Using unity filler image functionality in order to move the bar as a percentage.