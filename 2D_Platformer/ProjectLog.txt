19th January 2016
---------------------

Today I implemented the code for moving platforms. This required a new "MovingPlatform" script, and some changes to the "Player" script.

I originally thought the process would be very simple. I could use the same principles I used to allow the AI agent to move, in order to
allow the platform to move. This is the code I added to the "MovingPlatform" script, and it pretty much did the job. The platform I attached the script to
moved nicely. If I jumped onto it with the player character, the collision worked fine, and I could ride it down. However on the way back up, the 
PlayCharacter would play the "Falling" animation and I would lose all control of it until the platform reached the top and started to move back down again.
Clearly this needed to be fixed.

I decided the best course of action was to edit the "Player" script so that the it could detect when the player was stood on ontop of the moving platform
and ensure that the falling animation did not play.

I believe the reason this bug occurred at all was due to the fact that the colliders on the players feet and the platform weren't behaving correctly so I
couldn't use them to detect whether or not the player is on the platform so I decided instead to look at the player's X/Y coordinates and check them against
the X/Y coordinates of the platform. If they were close enough to each other, I could treat the player as if he was just stood on solid ground, and therefore
the player wouldn't lose control, and the falling animation wouldn't play.

This actually worked pretty well. The main complexity came when I needed to consider how to implement this for multiple moving platforms throughout the level,
as they will all have their own set of X/Y coordinates. I originally tried to loop through all of the MovingPlatforms I could find using the line 
"GameObject.Find("MovingPlatform (" + index.ToString() + ")");" but this was causing performance issues as GameObject.Find is a performance intensive operation,
and I was calling it multiple times in a loop, every time the Update() procedure was called.

I decided the best course of action to correct this was to create an ArrayList and populate it with all of the MovingPlatforms using GameObject.Find
within the Start() procedure. I could then access the arraylist later within the Update() method with much less of a hit to performance.

20th January 2016
-----------------------

Added a shooting animation. Note that no back end projectile system is in place yet, there is no collision detection on projectiles and health and damage 
systems still don't exist for the player and enemies. Animating the player for shooting was fairly similar to most other animations so that was done fairly 
quickly. The new challenge to this task was to spawn the projectiles in the game. This was done with a simple bullet script, and some changes to the player
script.

The first step was to make the bullet animation a prefab (this is basically just a template from which objects can be created). Once this was done, I made
a SerializedField in the player script so that I could simply drag the prefab into it from Unity, this then gives me access to the prefab within the player
script. I then wrote a function that instantiates the bullet prefab. I needed the bullet to know which direction to travel in once it had been fired so
I needed to pass a Vector to a function in the Bullet script based on which way the player is facing.

The Bullet script was fairly simple. The initialize function decided on the direction it should travel based on the Vector passed by the Player script,
after this the bullet simply set it's velocity to speed( a serialized field) * direction. Due to the fact that the player script can create these objects
at a rapid rate, the bullet objects needed to know when to destroy themselves otherwise I could run into serious performance issues. Currently I am overriding
the OnBecameInvisible function (which is called whenever an object is not within view of the camera) so that the bullets destroy themselves whenever they
leave the Camera's view. However this will likely need to be changed in the future.

Overall I expect the Bullet script to become more complex when I start to add the back end projectile system.

Added an "Agent" Script, this will be the super class for all simple AI agents. Almost all of "Slimes" functionality is currently inherited.

21st January 2016
------------------

Today I started work on damage and health for the player and the AI. After creating all 4 animations, I then  gave both of them an integer "hitpoints" 
that keeps track of health. I also created two new functions in each. One responsible for damaging the health, and one to check whether or not the 
player or agent is still alive.

Once this was done, it was possible for both player and AI to keep track of their health, damage it and play the death animation when necessary, so the next
step was to actually create things to trigger damage on each of them.

I added a collider to the "Bullet" prefab, and then in the Agent script I wrote the OnTriggerEnter2D function (called when something collides with the agent's
hitbox.). I made this function check to see if the object that collided with the agent is a bullet, and if so, call the TakeDamage function for the agent.

The next thing I worked on was the player's melee attack. I created a new collider that is actually disabled by default. When the player presses the melee
attack key, the collider is enabled. In this way I can use the OnTriggerEnter2D function in the agent script to check if it has collided with the player's
melee attack hitbox, if so it could call the TakeDamage function.

This was particularly challenging because there seems to be a bug where if the player is stood still and the agent is stood next to him, and the player
attacks, the agent does not register the hit. Obviously this is very bad because that is one of the few times someone would want to use a melee attack.
A fix to this that seems to work for now is to increase the player's velocity by a negligible amount, this makes the agent register the hit. Although
I would like to revisit this fix and hopefully come up with a nicer solution. 


25th January 2016
-----------------
Today I added the functionality for the Slime AI to attack the player. At first this was quite similar to how it worked for the player. I added a meleehithox
to the slime and told it to enable the hitbox when it called its attack function. I told the player to take damage if it collided with the Slime's meleehitbox.
The problem with this was that the slime actually doesn't have an attack animation. So it was calling the attack function far too quickly and was instantly
killing the player. Although this could pose an interesting challenge I don't think it is acceptable for the first AI the player is going to encounter.
I added functionality to temporarily provide immunity to the player after taking damage. This was tricky to implement at first, I toyed with the idea
of using a seperate thread to track this but later came across the Time.deltaTime property in C# which allowed me to write my own UpdateImmunity function 
instead.

Next I would like to make the slime back off after attacking so that it gives the appearance that the slime is hurting the player with it's momentum
rather than it's mere presence (due to the lack of an attack animation.)

I added the code to the agent script to make the slime back off between attacks. I also added code to the Player script to make the player sprite
flicker while it is immune to damage. This provides a useful visual cue to the player.

